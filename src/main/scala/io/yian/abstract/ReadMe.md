# 추상화
오브젝트 지향언어에서는 추상클래스나 추상메소드는 상속을 받아서 구체화하도록 하는것이 일반적이다.
Scala에서는 클래스나 메소드뿐만이 아니라 필드, 타입 까지도 추상화로 선언할 수있다.

이전파트에서는 형파라메타를 사용하여 형자체를 클래스나 메소드 파라메타로하여 처리하는 방법에 대하여 다루었다.
형파라메타는 오브젝트 언어에 있어서 일반적인 기능이지만, Scala는 [추상형]라고 부르는 형태도 사용된다.

[추상형]이란 클래스나 트레이냉내 타입을 지정하지 않은 멤버를 가리킨다. [type] 키워드를 사용하여 클래스/트레이
멤버를 선언하고, 그 클래스/트래이를 계승또는 MixIn한 클래스로 구체적인 타입을 지정한다.

## [type] 키워드로 추상형 선언
추상형을 사용하는 방법에 대해 다룬다. REPL을 기동하고 추상형을 선언한 Base 라는 추상클래스를 선언한다.
```
abstract class Base {
	type SomethingFoo
	def show(something: SomethingFoo)
}	
```
추상클래스 Base에는 [type SomethingFoo]라고 선언하고 있는 부분이 [추상형]타입이다.[SomethingFoo]명명으로 추상형을 선언한 것이다.
이부분이 실제 프로그램 동작에 있어서 어떠 형인지는 이 시점에서는 알 수 없지만, 이타입을 파라메타로 받은 show 메소드를 가지고 있다.

### 추상형 사용 방법
추상형으로 지정된 Foo클래스와 Base클래스를 계승한 Ex1클래스를 선언해본다. Ex1클래스에서는 앞의 SomethingFoo에 Foo클래스를 지정하고 있다.
이에 따라 위에서 선언한 SomethingFoo추상형에 구체적인 Foo라는 형이 지정된다. show메소드에서는 SomethingFoo(Foo)의 exec메소드를 호출하도록 구현하고 있다.
```
class Foo {
	def exec = println("Foo#exec실행:)
}	

class Ex1 extends Base {
	type SomethingFoo = Foo
	def show(something:SomethingFoo) = something.exec
}
```
마지막으로 Ex1클래슬를 인스턴스화한다. show메소드에 Foo를 대입하는 것을 볼 수 있다.
```
> val x = new Ex1
> x.show(new Foo)
```

### 추상형에서 형경계 지정
형파라메타와 마찬가지로 추상형에도 형경계를 지정할 수 있다. 아래와 같이 추상형SomethingFoo에 지정할수 있는 타입을 Foo클래스 또는 Foo를 상속받은 클래스로 한정하고 있다.
```
abstract class Base {
	type SomethingFoo <: Foo
}
```

### Alias지정하기
type에는 타입명 길이로 인한 가독성을 높이기 위해서 Alias를 지정할 수 있다. type은 형파라메타도 포함한 상태에서 Alias를 사용할 수 있기 때문에 아래와 같은 방법으로 기술량을 줄일 수 있다.
```
type x = List[(Int, String, Double)]
def func(arg1:X, arg2:X):X = . . .
```

### 암묵적 형변
암묵적 형변환(implicit conversion)이란 어떤 타입으로 부터 별도의 타입으로 사전에 변환용함수를 만들어 두어 자동으로 변환용함수를 호출하도록 하는 기능이다.
예를 들어 아래와 같이 String타입 변수에 Int타입의 값을 대입하려고 하는 경우 서로다른 타입이기 때문에 에러가 나는것이 당연하다.
```
> val str:String = 10
...error...
```

### 암묵적 형변환시키는 함수를 정의한다. [implicit]
암묵적 형변환 시키는 함수를 정의한다. 암묵적 형변환시키는 함수는 [implicit]키워드를 부여하고, 파라메타에 변환하기 전 타입, 리턴값에는 변환 후의 타입을 지정한다.
```
implicit def
intToString(num:Int):String = {
	println("Int ==> String 변환")
	num.toString
}
```
다시한번 String타입의 변수에 Int타입 값을 대입해 본다.
```
> val str:String = 10
str:String = 10 
```
위의 결과에서 보듯이 암묵적 형변환하는 함수가 호출되고 형변환되는 것을 확인 할 수 있다. 어떻게 이런 동작을 하게 되는지 설명을 한다.

implicit 키워드가 부여된 함수는 타입체크에러를 수정하기 위해 컴파일러가 프로그램에 주입하는 함수이다. 소스상에 [a + b]라는 식의 타입체크 에러로 인해 컴파일이 안되는 경우 [암묵적형변환함수(a) + b]라는 처리로 변환되어 컴파일하게 된다. 암묵적형변환함수가 a를 +멧소드를 가지는 타입으로 변환이 되면 그대로 동작하다. 암묵적형변환을 하는 함수가 간단한 변환함수이고 그 기술을 생략할 수 있다면 소스는 한층더 간결해 진다. 

함수명은 대체적으로 [변환전타입]to[변환후타입]으로 하는 경우가 많다.

### Date형에서 String형으로 암묵저형변환
한가지 예를 더 들어 본다. Date형에서 String형으로 암묵적형변환을 하는 함수를 정의 한다. SimpleDateFormat을 사용하여 Date형을 고정포맷 문자열로 변화한다.
```
implicit def
dateToString(date:java.util.Date):String = {
	import java.text._
	println("java.util.Date에서 String으로 변환")
	val sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss")
	sdf.format(date)
}

> val strDate:String = new java.util.Date()
== you will check this example in repl of scala ==

```

## 암무적형변환 기본 룰
### implicit부여된 정의만 암묵적변환으로 사용되어 진다.
변환용함수에 implicit키워드가 부여되지 않으면 암묵적형변환으로 그 함수가 사용되어지지는 않는다.

### 암묵적형변환은 단일 식별자로서 스콮프내에 있어야 한다.
implicit함수가 정의되어 있다고 해서 내부영역에 선언되어 있지 않으면 적용되지 않는다.

예를 들어 위의 예제 dateToString함수가 별도의 패키지나 별도의 오브젝트내에 정의되어 있다면 단일 식별자(dateToString)로 사용할 수 없기 때문에 그대로 적용되지 않는다. 이경우 import로 단일식별자로서 사용할 수 있도록 할 필요가 있다. 
(컴패니언 오브젝트내에 implicit정의가 되어 있는 경우는 예외로 한다.)

### 암묵적변환은 단 한번만 실행된다.
암묵적 형변환으로 변환된 결과는 또 한번 암묵적 변환을 할 수가 없다.

### 암묵적형변환을 적용할 수 있는 함숙수 2개이상있는 경우 에러가 난다.
앞의 Date에서 String으로 변환하는 예를 들면 dateToString과 같은 시그니처를 가지는 implicit함수가 하나 더 있을 경우 에러가 발생 된다.

### 타입체크로 문제가 없으면 암묵적변환은 하지 않는다.
소스파일에 기술된 그대로 체크하여 이상이 없는 경우 암묵적형볂환은 하지 않는다.

이상이 암묵적형변환에 있어서 기본적인 룰이다. 암묵적형변환을 사용할때는 예기치않은 형변환을 방지하기 위해 implicit함수를 전용 오브젝트에 정의하고, 개별로 import하도록 하는 습관을 들이도록 한다.

다음은 파라메타를 생략할 수 있는 암묵적 파라메타를 소개한다.

## 암묵적 파라메타
암묵적 파라메타(implicit parameter)란 파라메타 타입에 맞는 암묵적인 값을 준비해 두는 것으로, 메소드호출시 파라메타를 생략할 수 있는 구조이다. 기술방법은 아래와 같다.
```
def 메소드명(implicit 파라메타명:타입며):리턴타입명 = 함수내용
```
파라메타 앞에 implicit키워드를 사용하여 그 파라메타를 암묵적으로 사용할 수 있다. 여기서 중요한것은implicit키워드는 맨 앞의 파라메타에만 부여할 수 있기 때문에 이경우 아래와 같이 종종 사용되어 진다.
```
def 메소드명(파라메타명:타입명)...(implicit 파라메타명:타입명):리턴타입명 = 함수내용
```

### 복수의 파라메타 리스트
복수의 파라메타 리스트라 함수 파라메타를 분리해서 기술하는 방법이다. 예를 들어 3개의 파라메타를 모두 더하는 sum함수가 있다고 할때
```
> def sum(x:Int, y:Int, z:Int):Int = x+y+z
> sum(1,2,3)
== result ==
```
이것을 복수의 파라메타 리스트로 분리하면 아래와 같이 된다. 함수호출방법도 다르게 된다. 
```
> def sum(x:Int)(y:Int)(z:Int):Int = x + y + z
> sum(1)(2)(3)
== result ==
```
여기서 암묵적 파라메타를 사용하려면 먼저 2번째의 파라메타에 String형 implicit파라메타를 취득하는 greeting함수를 정의한다.
```
def greeting(name:String)
(implicit greet:String) = {
	println(greet + name)
}
```
이 함수를 실행하면 1번째 파라메타만 지정해도 암묵적인 값을 발견하지 않고 에러가 된다.
```
> greeting("Yiand")
== Error ==
```
암묵적 값이 없는 경우는 파라메타를 명시적으로 지정하면 문제없이 실행이 된다.
```
> greeting("Yian")("good morning")
== result ==
```
그럼 implicit파라메타로 암묵적 값을 설정해보자

implicit변수를 준비한다.
```
> implicit val hello:String = "AriAri"
```
greeting함수 1번째 파라메타만 지정하여 호출한다. 이번에는 implicit변수를 정의되어 있기 때문에 2번째 파라메타가 적용되는것을 확인할 수 있다.
```
> greeting("Yian")
== rsult ==
```
암묵적 파라메타는 파라메타타입과 스코프내의 타입을 매치시켜서 파라메타를 선택하게 된다. 암묵적변환과 같게 예기치 않은 파라메타 적용을 피하기 위해 암묵적 파라메타 타입에는 [암묵적 파라메타타입으롯로 사용함]라는 것을 목적으로한 특별한 타입을 준비해 두면 된다.

## 암묵적 형변환을 사용한 [가시경계]
그동안 형파라메타의 상한경계와 하한경계를 소개하였다. 상한/하한경계란 형파라메타로 지정한 형을 제한하려고 할때 사용하는 방법으로 형파라메타를 임의의 클래스의 서브클래스나 슈퍼클래스로 제한할 수 있다. 형파라메타의 경계지정에 대해서는 또다른 지정방법이 있다. [가시병계(view bound)]라고 하는 지정방법이 있다.

### 가시경계 지정방법
가시경계는 아래와 같이 지정한다.
```
class X[A <% T]
```
A는T의 서브클래스인지 암묵적형변환으로 A에서 T로 변환가능한 타입(A를T로서 다루는 타입)을 조건으로 한다.

### 가시경계 지정 예제
Z클래스에서는 
```
[ A <% X ]
```
로 가시경계를 지정하고 있다. 이것은 [Z클래스의 형파라메타로 지정할 수 있는 형은 X의 서브타입 또는 암묵적형변환으로 X로 변환할 수 있는 형]라는 의밍이다.
```
class X
class Y
class Z[A <% X]
```
Z클래스를 인스터스화를 해본다. 형파라메타로 X클래스를 지정하고 있는 경우는 문제가 없다. Y클래스를 지정한 경우 상태로는 Y클래스를 X클래스로 변환할 수 업기 때문에 에러가 된다.
```
> val a = new Z[X]
== result ==
> val a = new Z[Y]
== error ==
```
Y클래스에서 X클래스로 암묵적변환을 하는 함수를 만들어 본다. 이 함수는 특별히 의미가 있는건 아니다. X의 인스턴스를 반환하는 것 뿐이다.
```
implicit def yTox(y:Y):X = new X
```
다시 한번 Y클래스를 Z클래스 형파라메타로 지정하여 인스턴스화 시켜본다.
```
> val a = new Z[T]
== result ==
```
이번에는 Y클래스에서 X클래스로 암무적형변환을 하는 함수가 정의되어 있기 때문에 문제없이 인스턴스화할 수 있었다. 이와 같이 가시경계에서는 [그타입으로서 다룰것인가 아닌가]로 형파라메타로서 지정할수 있는지를 판단한다.

## 형파라메타의 제약
형파라메타와 implicit에 관련한 기능을 한가지 소개한다. 암묵적 파라메타를 이용하면 형파라메타가 특정 클래스에만 호출되어 지는 제약을 가지고, 이것을 컴파일시에 체크되는 메소드를 작성할 수 있다. 이것을 [형파라메타제약(Generalized Type Constraints)]라고 한다. 
형파라메타 제약에는 몇가지 종류가 있기 때문에 하나씩 소개한다.

### A =:= B 
먼저 [A =:= B]라는 파라메타 제약이다. 이것은 A형이 B형과 같은경우 메소드를 호출하는 제약이다.
아래에 예제를 들어본다. X클래스는 형파라메타 하나를 취득한다. 취득한 파라메타는 어떤것을 지정하여도 문제가 발생되지 않지만, exec메소드를 사용하기 위해서는 형파라메타가 Int형이지 않으면 안되는 제약이 되어 있다.
```
class X[A] {
	def exec(implicit t:A =:= Int):Unit = println("exec")
}
```
암묵적 파라메타를 사용하고, [=:=(Predef클래스에 정의되어 있다)]로 형파라메타가 어느 타입인지를 체크하다. 실제로 X클래스를 사용해보도록 한다. 형파라메타에 Int형과 String형 각각 지정하고 동작을 확인한다.
```
> val x = new X[Int]
> x.exec
== result ==
> val x2 = new X[String]
> x2.exec
== error ==
```
형파라메타에 Int형을 지정한 경우 exec메소드도 문제없이 사용할 수 있다. 형파라메타에 String형을 지정한 경우 X클래스 인스턴스화할 경우 문제없지만, exec메소드를 호출할때는 에러가 발생된다.

### A <:< B
다음은 
```
[A <:< B] 
```
라는 제약이다. 이것은 [A는 B와 같고, 또는 서브클래스이다]라는 제약이다.
Base클래스와 이것을 상속받은 Ex1클래스 그리고 Another클래스를 준비한다. Y클래스에서는 형파라메타 제약을 Base나 서브클래스로 제약하고 있다.
```
class Base
class Ex1 extends Base
class Another

class Y[A] {
	def exec(implicit t:A <:< Base):Unit = println("exec")
}
```
Y클래스를 인스턴스화하여 본다. 형파라메타에 Ex1클래스와 Another클래스를 지정하고, 각각 확인을 해본다.
```
> val y = new Y[Ex1]
> y.exec
== result ==
> val y2 = new Y[Another]
> y2.exec
== error ==
```
Base클래스를 상속받은 Ex1클래스를 형파라메타로 지정한 경우는 exec메소드를 호출하는 경우 문제가 없다. Base클래스와 관계없는 Another클래스를 지정한 경우는 exec메소드를 호출한 경우 에러가 발생되는 것을 확인할 수 있다.

### A => B
마지막으로 [A => B] 라는 제약이다. 이것은 앞에 소개하였던 가시경계와 의미가 같다. [A는 암묵적형변환으로 B로 변환할 수 있다(A를B로서 다루다)]라는 제약이다.
```
(Scala 2.9에서 표기법은[A <%< B] 였지만 현재버전에는 쓰이지 않는다
```
아래와 같이 예를 들어 본다. Z클래스에서는 형파라메타제약을 [지정한 클래스는 Y클래스로서 다룬다]라는 제약이다.
```
class X
class Y
class Z[A] {
	def exec(implicit t:A => Y):Unit = println("exec")
}
```
X클래스를 형파라메타로 지정해서 Z클래스를 인스턴스화해본다.
```
> val z = new Z[X]
> z.exec
== error ==
```
X클래스를 Y클래스로 변환하는 암묵적형변환함수는 아직 준비되어 있지 않기 때문에 exec메소드를 사용하여도 에러가 발생된다. 그럼 X클래스를 Y클래스로 변환하는 암묵적형변환함수를 정의하고 한번더 exec메소드를 호출 하도록 한다.
```
implicit def xToy(x:X):Y = new Y
> z.exec
== result ==
```
이번에는 exec메소드가 정상적으로 동작이 되었다. 상한/하한경계나 가시경계에서는 형파라메타로 지정하는 형을 제약할수 있지만, 형파라메타 제약(Generalized Type Constraints)에서는 형파라메타로 지정하는 형이 아닌 사용할 수 있는 메소드를 제약할 수 있다.

## 버그의 원인이 되지 않도록 잘 사용해야 한다
이번장에서는 형파라메타과 같은 기능을 할 수 있는 추상형부터 시작하여 implicit키워드를 이용한 암묵적형변환과 암묵적파라메타, 그리고 형파라메타로 지정한 형제약으로 가시경계와 형파라메타제약을 소개하였다.
암묵적형변환이나 암묵적파라메타는 상당히 편리하게 사용되어 진다. 잘 사용하면 코드의 량을 줄여서 간결하게 프로그래밍할 수 있지만, 생각지 못한 버그의 원인이 되는 취약성을 가지고 있다. 암묵적형변환/암묵적파라메타를 사용할 때는 어떻게 적용할 것인가를 잘 생각하여 사용하길 바란다.


